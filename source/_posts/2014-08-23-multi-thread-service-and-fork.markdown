---
layout: post
title: 多进程下的fork及进程创建
date: 2014-08-23 14:00
comments: true
categories: 
  - Linux
  - Fork
  - Multi threads
---


在Linux中要启动一个新进程的方式通常是：先调用`fork()`函数fork出一个新的进程，然后在
新的进程中调用exec()函数来启动新的程序从而达到启动新程序的目的，比如下面的代码


```C
int start_prog(char *prog, char* args[])
{
  pid_t pid = fork();
  if (pid < 0) return -1;
  if (pid == 0) { // child pg
    if (execv(prog, args) < 0) return -1;
  } else {
    return 1;
  }
}

int main()
{
  char* args[] = {NULL};
  return start_prog("/bin/ls", args);
}

```

我们知道进程间的内存地址空间是隔离的，fork()系统调用的结果是生成一个新的子进程，为了启动新的程序，
需要调用exec*()系列函数来讲程序加载到当前进程空间。

为了保证隔离性，早期的UNIX采用在`fork()`将父进程的地址空间完整的复制一份。这个错误非常的耗时操作。
为了提高效率现代的Unix及Linux采用了一种称为`写时复制`的技术，其实也就是一种延迟操作的做法，实现时
是子进程和父进程在`fork()`时并不马上复制，而是暂时共享内存空间，随后只要父进程或者子进程试图写共享的
内存就会产生一个异常，这是内核才把内存空间进程复制，这减少了不必要的复制操作。比如我们在Shell中启动
一个程序`bash`程序就是先fork()一个子进程然后把我们想执行的程序启动，启动后的程序将会覆盖旧的内存空间，
也就是说父进程的空间将被替换。

下面说道重点，贴吧目前使用的HHVM来运行PHP程序，HHVM采用的是HI多线程模型，在使用HHVM之前我们使用的是
PHP-FPM，PHP-FPM采用的是多进程的模型。

在上周我们上线一个服务，发现上线后程序的CPU占用飚的非常高，经过分析发现程序话的最多时间的函数调用是`fork()`，
我们刚开始感觉很纳闷，PHP程序一般是不使用fork()的，而HHVM是多线程模型很少会用到fork()的，后来发现，
原来我们有个基础库的实现有问题，使用了PHP的`exec()`函数来启动shell程序做字符处理，PHP的exec的实现
是先fork()一个进程然后执行相应的命令，没有什么不对，对不对。但是为什么会导致CPU利用率过高呢？

从前面的介绍我们知道，启动新程序的时候利用了写实复制的技术避免不必要的消耗。但是对于我们来说，
我们使用的是多线程，在线上真实的应用中会不停的处理新的请求，也就是说，在某个线程在执行fork()的是时候
还会有其他线程在处理任务，那时不可避免的会写内存。这就触发了操作系统的写实复制，导致大量的内存
复制操作，导致资源占用急剧上涨。

说道这里你可能会说：你看，多线程不太好吧。HHVM好搓吧。其实对于PHP也会有类似的问题的，如果你使用的
是PHP的多线程模型(现在应该很少的人使用)。对于这个问题呢，HHVM使用了一个比较巧妙的方式来解决。
